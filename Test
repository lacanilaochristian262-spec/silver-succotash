--[[
    EasyLua V2 (Remake)
    only works on
     • Synapse X
     • Script-Ware
     • KRNL
     • Fluxus
    Only Advanced Exec ETC...
    (note: unfortunately this script won't work on delta/free mobile executors)
    also check out the original code: https://scriptblox.com/script/Universal-Script-EasyLua-V1-29655
]]

local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")

-- Detect exploit environment & available APIs
local detect = {}
detect.request = (syn and syn.request) or (http and http.request) or request or http_request or fluxus and fluxus.request or nil
detect.file = {}
do
    detect.file.writefile = type(writefile) == "function"
    detect.file.readfile = type(readfile) == "function"
    detect.file.isfile   = type(isfile) == "function"
    detect.file.delfile  = type(delfile) == "function"
    detect.file.appendfile = type(appendfile) == "function"
    detect.file.makefolder = type(makefolder) == "function"
    detect.file.isfolder   = type(isfolder) == "function"
    detect.file.delfolder  = type(delfolder) == "function"
end

-- Main API table
local EasyLua = {
    Version = "2.0.0",
    Env = {
        Request = detect.request,
        FileAPIs = detect.file
    }
}

-- Internal helper: safe request
function EasyLua:_SafeRequest(opts)
    -- opts: {Url, Method, Headers?, Body?}
    assert(type(opts) == "table", "Bad args to _SafeRequest")
    assert(opts.Url and type(opts.Url)=="string", "Missing Url")
    assert(opts.Method and type(opts.Method)=="string", "Missing Method")

    local req = self.Env.Request
    if not req then
        error("No HTTP request function available in this executor.")
    end

    local ok, result = pcall(req, {
        Url = opts.Url,
        Method = opts.Method,
        Headers = opts.Headers,
        Body = opts.Body
    })
    if not ok then
        return nil, result
    end
    return result
end

-- HTTP Helpers

-- Sends a GET request, returns body or nil, error
function EasyLua:GetPageContent(url)
    local res, err = self:_SafeRequest({Url = url, Method = "GET"})
    if not res then return nil, err end
    return res.Body
end

-- Sends a GET request and parses JSON
function EasyLua:GetJSON(url)
    local body, err = self:GetPageContent(url)
    if not body then return nil, err end
    local ok, data = pcall(HttpService.JSONDecode, HttpService, body)
    if not ok then
        return nil, data  -- data is error message
    end
    return data
end

-- POST JSON data
function EasyLua:PostJSON(url, tbl, headers)
    local headers = headers or {}
    headers["Content-Type"] = "application/json"
    local body = HttpService:JSONEncode(tbl)
    local res, err = self:_SafeRequest({
        Url = url,
        Method = "POST",
        Headers = headers,
        Body = body
    })
    if not res then return nil, err end
    -- Try to decode response body
    local ok, data = pcall(HttpService.JSONDecode, HttpService, res.Body)
    return ok and data or res.Body
end

-- Webhook helper (send message to webhook)
function EasyLua:SendWebhook(webhookUrl, content)
    assert(type(webhookUrl)=="string", "Webhook URL must be string")
    assert(type(content)=="string", "Webhook content must be string")
    return self:PostJSON(webhookUrl, { content = content })
end

-- File Helpers (exploit only)

function EasyLua:WriteFile(path, content)
    assert(self.Env.FileAPIs.writefile, "writefile not supported")
    writefile(path, content)
end

function EasyLua:ReadFile(path)
    assert(self.Env.FileAPIs.readfile, "readfile not supported")
    return readfile(path)
end

function EasyLua:IsFile(path)
    return (self.Env.FileAPIs.isfile and isfile(path)) or false
end

function EasyLua:DeleteFile(path)
    assert(self.Env.FileAPIs.delfile, "delfile not supported")
    delfile(path)
end

function EasyLua:AppendFile(path, content)
    assert(self.Env.FileAPIs.appendfile, "appendfile not supported")
    appendfile(path, content)
end

function EasyLua:MakeFolder(path)
    assert(self.Env.FileAPIs.makefolder, "makefolder not supported")
    makefolder(path)
end

function EasyLua:IsFolder(path)
    return (self.Env.FileAPIs.isfolder and isfolder(path)) or false
end

function EasyLua:DeleteFolder(path)
    assert(self.Env.FileAPIs.delfolder, "delfolder not supported")
    delfolder(path)
end

-- Config System: saving and loading config tables (JSON)

function EasyLua:SaveConfig(path, tbl)
    assert(type(path)=="string", "path must be string")
    assert(type(tbl)=="table", "config must be table")
    if not self.Env.FileAPIs.writefile then
        error("File write not supported")
    end
    local ok, encoded = pcall(HttpService.JSONEncode, HttpService, tbl)
    if not ok then error("Failed to encode config: ".. tostring(encoded)) end
    writefile(path, encoded)
end

function EasyLua:LoadConfig(path, default)
    assert(type(path)=="string", "path must be string")
    default = default or {}
    if self:IsFile(path) then
        local content = self:ReadFile(path)
        local ok, decoded = pcall(HttpService.JSONDecode, HttpService, content)
        if ok then
            return decoded
        else
            warn("Failed to parse config JSON, returning default. Error: ".. tostring(decoded))
            return default
        end
    else
        return default
    end
end

-- UI Helpers

-- Simple notification (floating text for a short time)
function EasyLua:Notify(player, message, duration, color)
    -- Exploit-only / GUI
    local duration = duration or 3
    color = color or Color3.fromRGB(255,255,255)
    if not Players.LocalPlayer then return end

    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "EasyLuaNotification"
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(0, 300, 0, 50)
    label.Position = UDim2.new(0.5, -150, 0.3, 0)
    label.BackgroundTransparency = 0.5
    label.BackgroundColor3 = Color3.fromRGB(0,0,0)
    label.TextColor3 = color
    label.Text = "[EasyLua] " .. message
    label.TextScaled = true
    label.Parent = screenGui

    task.delay(duration, function()
        if screenGui then screenGui:Destroy()
    end)

    return label
end

-- Template Generator

EasyLua.Templates = {}

-- Generates a basic ESP (Name over head through walls)
EasyLua.Templates.ESP = [[
-- ESP Template
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer and plr.Character then
        local head = plr.Character:FindFirstChild("Head")
        if head then
            local billboard = Instance.new("BillboardGui", head)
            billboard.Name = "EasyLuaESP"
            billboard.Adornee = head
            billboard.Size = UDim2.new(0,100,0,20)
            billboard.AlwaysOnTop = true

            local label = Instance.new("TextLabel", billboard)
            label.Size = UDim2.new(1,1,1,1)
            label.BackgroundTransparency = 1
            label.Text = plr.Name
            label.TextColor3 = Color3.new(1,0,0)
            label.TextStrokeTransparency = 0
        end
    end
end
]]

-- Generates a smooth aim skeleton (without exploit)
EasyLua.Templates.SmoothAim = [[
-- Smooth Aim Template
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local AimKey = Enum.KeyCode.E
local Smoothing = 0.2
local MaxDist = 100

local function findTarget()
    local closest, dist = nil, math.huge
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr~=LocalPlayer and plr.Character and plr.Character:FindFirstChild("Head") then
            local headPos = plr.Character.Head.Position
            local myPos = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart") and LocalPlayer.Character.HumanoidRootPart.Position
            if myPos then
                local d = (headPos - myPos).Magnitude
                if d < MaxDist and d < dist then
                    closest, dist = plr, d
                end
            end
        end
    end
    return closest
end

local aiming = false
-- pressing key to toggle
game:GetService("UserInputService").InputBegan:Connect(function(i,g)
    if not g and i.KeyCode == AimKey then aiming = true end
end)
game:GetService("UserInputService").InputEnded:Connect(function(i,g)
    if not g and i.KeyCode == AimKey then aiming = false end
end)

RunService.RenderStepped:Connect(function()
    if aiming then
        local target = findTarget()
        if target then
            local head = target.Character.Head
            local camCFrame = Camera.CFrame
            local look = CFrame.lookAt(camCFrame.Position, head.Position)
            Camera.CFrame = camCFrame:Lerp(look, Smoothing)
        end
    end
end)
]]

-- Generate code from template
function EasyLua:GetTemplate(name)
    return self.Templates[name] or error("Template not found: ".. tostring(name))
end

-- Event System

EasyLua._Events = {}

function EasyLua:On(eventName, callback)
    assert(type(eventName)=="string", "eventName must be string")
    assert(type(callback)=="function", "callback must be function")
    if not self._Events[eventName] then
        self._Events[eventName] = {}
    end
    table.insert(self._Events[eventName], callback)
end

function EasyLua:Fire(eventName, ...)
    local listeners = self._Events[eventName]
    if not listeners then return end
    for _, cb in ipairs(listeners) do
        task.spawn(cb, ...)
    end
end

-- Example custom event: when HTTP GET returns JSON
function EasyLua:GetJSONAsync(url)
    task.spawn(function()
        local data, err = self:GetJSON(url)
        self:Fire("JSONReceived", url, data, err)
    end)
end

--  usage 
comment
--[[
    -- How to use templates:
    local code = EasyLua:GetTemplate("ESP")
    print(code)  -- you can copy this template

    -- How to use config:
    local cfg = EasyLua:LoadConfig("myconfig.json", { setting1 = true })
    cfg.setting1 = false
    EasyLua:SaveConfig("myconfig.json", cfg)
]]

return EasyLua
